# Модуль 5: ДЗ
• Принципи рекурсії та використання пам’яті для оптимізації алгоритмів
• Отримаєш досвід використання функцій в якості аргументів.
• Створення та використання кортежів для повернення кількох значень з функції.
• Використання генераторів в Python для ефективної ітерації та обробки великих об'ємів даних.
• Використання функціонального підходу, такого як використання функцій в якості аргументів та застосування функцій в функціональному стилі.
• Концепція декораторів в мові програмування Python та їх застосування для обробки помилок.



## Домашнє завдання 1 — Замикання та кешування (Fibonacci)

### Опис
У цьому завданні реалізовано обчислення чисел Фібоначчі з використанням **замикання** та **кешування результатів**.

Функція `caching_fibonacci()` створює внутрішню функцію `fibonacci(n)`, яка:
- зберігає кеш обчислених значень у лексичному контексті;
- використовує рекурсію для обчислення чисел Фібоначчі;
- повертає результат з кешу, якщо значення вже було обчислене раніше.

### Вимоги до завдання
- Функція `caching_fibonacci()` повертає внутрішню функцію `fibonacci(n)`;
- `fibonacci(n)` обчислює n-те число Фібоначчі;
- якщо значення вже є в кеші, воно повертається без повторного обчислення;
- якщо значення відсутнє в кеші, воно обчислюється рекурсивно, зберігається та повертається;
- використовується рекурсія.

### Структура програми
- **Логіка обчислення** винесена у функцію `caching_fibonacci`;
- **Інтерактивна частина** (ввід користувача) розміщена у функції `main`;
- Блок `if __name__ == "__main__":` забезпечує запуск інтерактивного режиму лише при прямому запуску файлу.

### Приклад використання

python
fibonacci = caching_fibonacci()
print(fibonacci(10))  # 55

### Запуск програми

Для запуску в інтерактивному режимі виконайте:
python homework1_m5.py

Після запуску програма дозволяє вводити числа для обчислення відповідного числа Фібоначчі або ввести Exit для завершення роботи.

### Примітки
Кеш зберігається між викликами функції fibonacci;
Повторні виклики з однаковими аргументами виконуються значно швидше;
Рішення демонструє принцип роботи замикань у Python.