# Модуль 5: ДЗ
• Принципи рекурсії та використання пам’яті для оптимізації алгоритмів
• Dикористання функцій в якості аргументів.
• Створення та використання кортежів для повернення кількох значень з функції.
• Використання генераторів в Python для ефективної ітерації та обробки великих об'ємів даних.
• Використання функціонального підходу, такого як використання функцій в якості аргументів та застосування функцій в функціональному стилі.
• Концепція декораторів в мові програмування Python та їх застосування для обробки помилок.



## Домашнє завдання 1 — Замикання та кешування (Fibonacci)
Файл - homework1_m5.py

### Опис
У цьому завданні реалізовано обчислення чисел Фібоначчі з використанням **замикання** та **кешування результатів**.

Функція `caching_fibonacci()` створює внутрішню функцію `fibonacci(n)`, яка:
- зберігає кеш обчислених значень у лексичному контексті;
- використовує рекурсію для обчислення чисел Фібоначчі;
- повертає результат з кешу, якщо значення вже було обчислене раніше.

### Вимоги до завдання
- Функція `caching_fibonacci()` повертає внутрішню функцію `fibonacci(n)`;
- `fibonacci(n)` обчислює n-те число Фібоначчі;
- якщо значення вже є в кеші, воно повертається без повторного обчислення;
- якщо значення відсутнє в кеші, воно обчислюється рекурсивно, зберігається та повертається;
- використовується рекурсія.

### Структура програми
- **Логіка обчислення** винесена у функцію `caching_fibonacci`;
- **Інтерактивна частина** (ввід користувача) розміщена у функції `main`;
- Блок `if __name__ == "__main__":` забезпечує запуск інтерактивного режиму лише при прямому запуску файлу.

### Приклад використання

``` python
fibonacci = caching_fibonacci()
print(fibonacci(10))  # 55
```

### Запуск програми

Для запуску в інтерактивному режимі виконайте:
python homework1_m5.py

Після запуску програма дозволяє вводити числа для обчислення відповідного числа Фібоначчі або ввести Exit для завершення роботи.

### Примітки
Кеш зберігається між викликами функції fibonacci;
Повторні виклики з однаковими аргументами виконуються значно швидше;
Рішення демонструє принцип роботи замикань у Python.

## Домашнє завдання 2 — Генератори та регулярні вирази
Файл - homework2_m5.py

### Опис
У цьому завданні реалізовано пошук та підсумовування дійсних чисел у тексті з використанням **генераторів** та **регулярних виразів**.

Програма аналізує текстовий рядок, знаходить усі дійсні числа, які вважаються частинами доходів, та обчислює їх загальну суму.

### Умови задачі
- Дійсні числа у тексті записані коректно;
- Кожне число чітко відокремлене пробілами з обох боків;
- Для пошуку чисел необхідно використовувати регулярні вирази;
- Для обробки чисел застосовується генератор.

### Реалізовані функції

#### `generator_numbers(text: str)`
Функція аналізує текст і повертає **генератор**, який по черзі видає всі дійсні числа, знайдені у рядку.

Особливості:
- використовується регулярний вираз для ідентифікації чисел;
- числа повертаються у вигляді типу `float`;
- застосовується конструкція `yield`.

#### `sum_profit(text: str, func: Callable)`
Функція використовує передану генераторну функцію для підсумовування всіх чисел у тексті.

Параметри:
- `text` — вхідний текст;
- `func` — функція-генератор для пошуку чисел.

Функція ітерується по генератору та обчислює загальний прибуток.

### Приклад використання

``` python
text = (
    "Загальний дохід працівника складається з декількох частин: "
    "1000.01 як основний дохід, "
    "доповнений додатковими надходженнями 27.45 і 324.00 доларів."
)

total_income = sum_profit(text, generator_numbers)
print(f"Загальний дохід: {total_income}")
```


### Результат
Програма коректно знаходить усі дійсні числа в тексті та виводить їх суму.

### Примітки
Генератор дозволяє обробляти числа без створення проміжних списків;
Рішення демонструє практичне використання генераторів і регулярних виразів у Python;
Логіка пошуку чисел та підсумовування розділена для зручності повторного використання.

## Домашнє завдання 3 — Python-скрипт  для аналізу лог-файлів.
Скрипт зчитує лог-файл, підраховує кількість записів для кожного рівня логування (INFO, DEBUG, WARNING, ERROR) та виводить статистику у вигляді таблиці.
За потреби користувач може передати додатковий аргумент командного рядка для перегляду всіх записів певного рівня логування.

### Формат лог-файлу
Очікується, що лог-файл має наступний формат:
YYYY-MM-DD HH:MM:SS LEVEL Message

### Функціональність
Скрипт реалізує наступні можливості:
зчитування лог-файлу, переданого як аргумент командного рядка
парсинг кожного рядка логу на дату, час, рівень логування та повідомлення
підрахунок кількості записів для кожного рівня логування
виведення статистики у табличному вигляді
фільтрація логів за заданим рівнем логування
обробка помилок читання файлу

Реалізовані функції
parse_log_line(line: str) -> dict
Парсить рядок логу та повертає словник з ключами: date, timestamp, log_level, message.
load_logs(path: str) -> list
Зчитує лог-файл та повертає список розпарсених записів.
filter_logs_by_level(logs: list, level: str) -> list
Фільтрує записи логу за заданим рівнем логування.
count_logs_by_level(logs: list) -> dict
Підраховує кількість записів для кожного рівня логування.
display_log_counts(counts: dict)
Форматує та виводить статистику за рівнями логування у вигляді таблиці.

### Обробка помилок
Скрипт коректно обробляє:
відсутність файлу
неправильний шлях до файлу
помилки читання файлу
некоректний рівень логуванн

## Домашнє завдання 4 - Console Assistant Bot 
Файл - homework4_m5.py

### Опис проєкту

Цей проєкт — консольний бот-помічник, який працює з контактами користувача.
Бот дозволяє додавати контакти, змінювати номер телефону, отримувати номер за ім’ям
та переглядати всі збережені контакти.

У четвертому домашньому завданні основний акцент зроблено на **обробці помилок введення
користувача за допомогою декораторів**.

---

### Функціональність

Бот підтримує такі команди:

- `add <name> <phone>` — додати новий контакт
- `change <name> <phone>` — змінити номер телефону існуючого контакту
- `phone <name>` — отримати номер телефону за ім’ям
- `all` — показати всі збережені контакти
- `hello` — привітання
- `exit` або `close` — завершення роботи бота

---

### Обробка помилок

Для обробки помилок використовується декоратор `input_error`.

Декоратор перехоплює такі винятки:
- `ValueError` — неправильна кількість аргументів
- `IndexError` — відсутні обов’язкові аргументи
- `KeyError` — звернення до неіснуючого контакту

Завдяки декоратору:
- програма **не завершується при помилці**
- користувач отримує **зрозуміле повідомлення**
- логіка обробки команд залишається чистою та читабельною

---

### Приклад декоратора

``` python
def input_error(func):
    def inner(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except ValueError:
            return "Enter the argument for the command Name Phone."
        except KeyError:
            return "Contact not found."
        except IndexError:
            return "Invalid command format."
    return inner

```
Кожна функція-обробник команд обгорнута цим декоратором.



### Висновок

Використання декораторів дозволяє централізовано обробляти помилки введення,
уникати дублювання коду та покращує структуру програми.
Бот коректно реагує на помилки користувача без аварійного завершення роботи.